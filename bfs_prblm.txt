problem with bfs

Input:-
let start = 3
end = 30
array = {2,5,10}

question:- minimum number of operations required to reach end from start if possible....otherwise print -1.

3*2*5 = 30(2 multiply)
3*10 = 30(1 multiply)

Input:- start = 2
end = 100
array={2,5,10}

2*2=
2*5 = 
2*10 = 
2*2*2=
2*2*5 = 
2*2*10 = 
2*5*2=
2*5*5 = 
2*5*10=100

ans will be 2


int findminimum(int start,int end,int arr[],int n)
{
     int vis[end+1];
     vis[start]=1;
      queue<pair<int,int>>qq;
       q.push(start,0);
        while(!q.empty())
       {
             int node = q.front().first;
             int steps = q.front().second;
             if(node == end) return steps;
             q.pop();
              for(int i=0;i<n;i++)
              {
	int dest = node*arr[i];
	if(dest<=end && !vis[dest]){
	q.push(dest,steps+1);
	vis[dest]=1;
	}
               }

        }
        return -1;
}










